# MY FIRST GITHUB

分享今天学习的一道算法题的笔记！
题目如下：给定一个整数数组nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。

int* singleNumber(int* nums, int numSize,int* returnSize)
{
	//同上一题的操作一样，最后的 ret=3^5 (此处假设 3 与 5 是那两个不同的数字）
	int ret = 0;
	for (int i = 0; i < numSize; i++)
	{
		ret ^= nums[i];
	}
	//由异或的特性，可知——两数必定有不同二进制位，使异或结果为 1
	//  0 1 1 -- 3
	//  1 0 1 -- 5
	//---------------
	//  1 1 0 -- 6
	// 
	//此处是找出第几个二进制位两者相异，
	//也就是找到 异或之后为 1 的二进制位
	int m = 0;
	while (m < 32)
	{
		//从右向左开始对比
		//按位与：1 与 1 的 才为 1
		if (ret & (1 << m))
			break;
		else
			m++;
	}
	//此处是将两个不同的数分离出来，
	//就算遇到 相同二进制位为1的数 也不担心，因为他们会成对出现在一组里
	//  1 1 0 -- 6   此处 m = 1 （因为 m 是重 0 开始的）
	//  1 0 1 0 -- 10
	//  0 0 1 0 -- 向左移了m位的 1（左移，右边补0）
	//------------------------------------
	//就会把两个 10 都 与 x1 进行异或
	int x1 = 0, x2 = 0;
	for (int i = 0; i < numSize; i++)
	{
		if (nums[i] & (1 << m))
		{
			x1 ^= nums[i];
		}
		else
		{
			x2 ^= nums[i];
		}
	}
	//此处这样操作的原因如下：
	//由于需要返回两个数，但是函数只能返回一个值，所以将数存放在一段地址之中
	int* retArr = (int*)malloc(2 * sizeof(int));
	retArr[0] = x1;
	retArr[1] = x2;
	*returnSize = 2;
	return retArr;
}

这是我的第一篇博客呀，如有不对之处，希望大家多多指正！
